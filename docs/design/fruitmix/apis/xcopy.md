<!-- TOC -->

- [1. 概述](#1-概述)
- [2. 使用](#2-使用)
  - [2.1. 创建](#21-创建)
  - [2.2. 层级与执行顺序](#22-层级与执行顺序)
  - [2.3. 命名冲突](#23-命名冲突)
    - [2.3.1. 策略](#231-策略)
    - [2.3.2. Policy对象](#232-policy对象)
    - [2.3.3. 全局策略和每个子任务策略](#233-全局策略和每个子任务策略)
  - [2.4. 错误](#24-错误)
  - [2.5. 任务失败](#25-任务失败)
- [3. 实现](#3-实现)
  - [3.1. 模型](#31-模型)
  - [3.2. 依赖性](#32-依赖性)
  - [3.3. 结构](#33-结构)
    - [3.3.1. XFile](#331-xfile)
    - [3.3.2. XDir](#332-xdir)
  - [3.4. Stepper](#34-stepper)
  - [3.5. Layers](#35-layers)
    - [3.5.1. 调度器](#351-调度器)
  - [3.6. 静态结构](#36-静态结构)
  - [3.7. 行为](#37-行为)
    - [3.7.1. 状态](#371-状态)
    - [3.7.2. 生命周期方法](#372-生命周期方法)
    - [3.7.3. 事件](#373-事件)
    - [3.7.4. 组合事件](#374-组合事件)
    - [3.7.5. 调度](#375-调度)
- [4. 测试](#4-测试)
  - [4.1. 分析](#41-分析)
  - [4.2. 状态机的状态](#42-状态机的状态)

<!-- /TOC -->

# 1. 概述

`xcopy`模块提供在服务器端批量复制和移动文件的功能。该功能不持久化任务，如果服务遭遇重启，则任务消失。

未来`xcopy`会提供服务器和云盘的上传下载功能，该功能需要持久化。


# 2. 使用

## 2.1. 创建

创建一个xcopy任务需要提供：

+ 模式，包括`copy`, `move`, `import`和`export`（未来会增加`upload`和`download`）
  + 在fruitmix文件系统内部的复制和移动使用`copy`和`move`
  + 从外部文件系统导入到fruitmix文件系统使用`import`
  + 从fruitmix文件系统导出到外部文件系统使用`export`
+ 一个源文件夹标识
+ 源文件夹下的一组文件或文件夹，以名称做标识
+ 一个目标文件夹标识

```js
{
  mode: 'copy',
  src: {
    drive: '虚拟盘uuid，或物理盘device name',
    dir: '文件夹uuid，或文件夹相对路径'
  },
  dst: {
    drive: '虚拟盘uuid，或物理盘device name',
    dir: '文件夹uuid，或文件夹相对路径'
  },
  entries: ['文件夹或文件名']，
  policies: {
    dir: [null, null],  // 用于文件夹操作遇到命名冲突时的解决策略   
    file: [null, null]  // 用于文件操作遇到命名冲突时的解决策略
  }
}
```

> 设计变更：不再需要客户端提供被文件或文件夹的UUID。


## 2.2. 层级与执行顺序

一个任务的行为具有层级结构的任务组合，每个子任务是一个文件夹任务或者一个文件任务。在任务执行顺序上采用如下设计规则：

1. 一个文件夹内既有子文件夹也有文件时，优先处理子文件夹任务；文件和文件夹均按照字母序操作；
2. 一个文件夹包含子文件夹时，采用深度优先原则；

第一条是考虑到在所有操作系统上，缺省的排列习惯都是文件夹优先于文件；

第二条是考虑如果用户浏览目标文件夹只能以top-down的方式操作，采用深度优先的原则可以明确表述任务尚未完成，而不会在上层看到建立了很多空文件夹，但并不清楚哪些件夹操作已经完成；

> 考虑到每次建立文件夹可能会带来一次readdir操作，第二条有可能变更为一次性建立完成所有文件夹。

举例如下：

```
<src>/
  hello/
    foo/
      dead/
      beef
    bar
  world
```

对于上述源文件结构，操作顺序应该是：

1. 建立hello/
2. 建立foo/
3. 建立dead
4. 复制beef
5. 复制bar
6. 复制world

## 2.3. 命名冲突

### 2.3.1. 策略

1. `undefined`或`null`, 无策略；当遇到同名对象时操作进入conflict状态，等待用户（客户端）解决；
2. `skip`, 遇到同名对象时跳过；如果源对象为文件夹，该文件夹内部的子文件夹和文件不会被继续复制或移动；
3. `merge`, 仅适用于源对下为文件夹且目标同名对象也为文件夹的情形，源文件夹内的子文件夹或文件会被继续复制或移动；
4. `replace`, 删除目标同名对象以完成复制或移动；
5. `rename`, 自动重命名；

### 2.3.2. Policy对象

1. Policy对象区分源对象和目标同名对象是相同类型还是不同类型；
2. 针对文件夹和文件使用不同的Policy；

每个policy对象用数组`[same, diff]`表示，其中`same`和`diff`分别为类型相同和类型不同时的策略；


### 2.3.3. 全局策略和每个子任务策略

全局具有`polices`属性，可以在创建任务时指定，也可以在任务运行时更新；更新全局`policies`一般在用户设置某个具体冲突时，在客户端提供“应用全部”选项，客户端可以根据该用户操作更新全局策略。

每个子任务也有自己的policy，目前的设计，每个子任务具有预设类型（根据源对象的类型）且不会变化，所以更新子任务的policy只需要提供一个policy对象。

全局策略的更新影响到所有已经冲突的任务，也影响到正在执行的任务。


## 2.4. 错误

错误不同于命名冲突；错误的任务无法重试。

对于一个文件任务而言，一个错误仅仅导致该任务进入错误状态。

对于文件夹任务，在建立目标文件夹的过程完成之后，如果遇到子任务错误，它需要考虑该子任务错误是否由当前文件夹任务的源或者目标文件夹变动所致。





可以预见到的错误包括如下类型：

1. 用户权限错误
    1. 用户不再能够访问源或目标文件夹
2. 源对象访问错误，包括：
    1. 源对象丢失
    2. 源对象类型变化
    3. 源对象为不支持的文件类型
3. 目标对象访问呢错误，包括：
    1. 目标对象为不支持的类型
4. 结构性错误
    1. 源对象的父文件夹、乃至整个任务的源文件夹，无法访问
    2. 目标对象的父文件夹、乃至整个任务的目标文件夹，无法访问



## 2.5. 任务失败

任务失败有很多种情况。

上一节的顺序要求，隐含了实现过程中需要完整读取一次目录，然后排序文件夹和文件任务的过程。

在完成读取目录之后，在子任务完成操作之前，文件系统的内容可能发生改动。这些改动可能导致：

1. 新建的文件夹或文件没有被复制或移动；
2. 文件夹和文件在对应任务执行完成之前被删除；
3. 文件夹和文件在对应任务执行完成之前被改动名称；
4. 当前（文件夹）任务对应的源文件发生变化（改名，移动到其他地方，删除）；

理论上，上述1/2/3问题可以通过把执行逻辑改为Iterator逻辑解决，即每个任务结束后都重新枚举文件夹内容，但这个做法会严重影响性能，且解决的问题是很少出现的，得不偿失。


# 3. 实现

## 3.1. 模型

`xcopy`设计为一个用户任务，它存在于vfs和nfs之外，代表用户执行操作。`xcopy`不持久化任何数据，如果遇到服务重启，则所有`xcopy`任务消失。

## 3.2. 依赖性

xcopy模块依赖vfs和nfs

## 3.3. 结构

每个task会创建一个`XCopy`对象；`XCopy`对象分为两层：context和task tree。

`XCopy`对象自身就是整个任务的context，它负责提供所有子任务所需：

1. api提供者，包括vfs和nfs；
2. 任务的全局信息，包括
    1. user
    2. src.drive和src.dir
    3. dst.drive和dst.dir
    4. entries，top level task
    5. global policies
    6. 统计和日志
    7. 全局调度器

### 3.3.1. XFile

`XFile`负责实现一个文件任务；一个文件任务包含如下状态：

1. Working，负责移动或复制文件
2. Conflict，遇到命名冲突，等待用户裁决
3. Failed，遇到错误
4. Finished，任务成功结束

`XFile`任务由全局调度器负责从文件的stat数据创建，创建的`XFile`对象成为task tree的一个节点，初始状态是`Working`；

`Working`状态需要注意的情况是在开始执行时应携带全局policy的副本，在执行结束时，如果执行结果是`Conflict`且全局`policy`发生变化，应重新执行任务；

`XFile`的父节点`XDir`对象需要侦听`XFile`的状态迁移，如果`XFile`迁移至`Failed`或者`Finished`状态，则`XFile`的生命周期结束，task tree的结构性修改是父节点的责任，触发调度器也是父节点的责任。

在职责分配上，一个状态结束时获取的数据如果影响向目标状态的迁移，则迁出的状态应该负责处理数据。

### 3.3.2. XDir

`XDir`负责一个文件夹任务；一个文件夹任务包含两个阶段：

1. 创建文件夹
2. 维护文件夹的子任务

`XDir`包含如下状态：

1. Mkdir，创建目标文件夹
2. Conflict，创建文件夹遇到命名冲突
3. Preparing，读取源文件夹内容，创建子文件夹
4. Failed，Mkdir或者Preparing遇到错误
5. Parent，等待子文件和文件任务
    + 具有子状态alarm
6. Finish，完成

`XDir`开始生命周期有两种方式：

如果目标文件夹存在，`XDir`从Preparing开始，包括根节点以这种方式开始。

在`Preparing`阶段，`XDir`执行如下步骤：

1. 读取源文件夹内容，如果遇到整体错误，迁移至Failed状态；
2. 在目标文件夹下批量建立源文件夹中的子文件夹
    + 如果遇到整体错误，迁移至Failed状态；
    + 如果遇到部分错误，计入错误统计后剔除错误的项目；
    + 如果无剩余内容，迁移至Finish状态；
    + 如果存在剩余内容，包括文件，遇到冲突的文件夹和成功建立目标文件夹的文件夹，迁移至Parent状态；

如果迁移至`Parent`状态，需要提供`fstats`和`dstats`两个数组；前者表述文件，每个元素是源文件的`stat`；后者表述文件夹，每个元素是源文件夹的`stat`，每个`stat`包含`dst`属性，其格式如下，对应`mkdir`操作的返回结果：

```js
{
  err,
  stat,
  resolved,
  policy
}
```

进入`Parent`状态时，`dstats`中的遇到冲突的项目，会立刻建立`XDir`放入children中，等待用户操作；此时`XDir`的状态是Conflict；如果用户更新了该项目的Policy，或者修改了全局的Policy，Conflict状态迁入Mkdir状态，该状态的结果是：

1. 如果失败，进入Failed状态；
2. 如果冲突，回到Conflict状态；
3. 如果成功，进入Preparing状态；

如果`Parent`状态下，`XDir`的所有children均完成，则迁入`Finish`状态。


     





## 3.4. Stepper

整个`xcopy`模块采用Stepper逻辑设计。

Stepper是一个灰盒逻辑，它要求状态机可以单步执行。

内部每个子任务单元并不暴露所有状态迁移给外部访问者，但是需要区分同步迁移和异步迁移，异步迁移是通过全局调度器实现的，控制该调度器可以实现单步执行。

## 3.5. Layers

每个task可以理解为两层逻辑：context层，和task tree层；

context层的职责是：

1. 提供task tree中的每个任务节点所需的基础api；
2. 调度任务；

task tree把整体任务拆解成任务单元；

任务包含文件任务和文件夹任务两种；



文件任务在context内调度，并发=2

文件夹任务包含如下状态：



根文件夹对象的建立是从ReadMake阶段开始的，ReadMake接受一组entries；

ReadMake状态执行以下任务：

1. 读取源文件夹的所有项目的stats；
    + 如果遇到整体错误，迁移至Failed
    + 对于根文件夹（有entries），如果有entry不存在，计入ignored列表；
2. 如果stats中不包含文件夹，迁移至parent；
3. 如果stats中包含文件夹，批量建立这些文件夹；
    + 如果遇到整体错误，迁移至Failed
    + 如果包含部分错误，剔除错误项，计入failed列表；
    + 其余的成功和冲突的部分作为参数，迁移至parent状态

Parent状态没有失败或者完成，由调度器计算其状态；只有Parent状态下，Dir对象具有Children。

### 3.5.1. 调度器

调度器不负责维护tree结构；tree节点自行通过Failed，Finish状态判断；

调度器负责根据Parent状态的Candidates，创建相应的Children任务






这两个阶段分开处理，前者使用XDir的类名，后者使用XPar的类名，表示`parent`；

创建目标文件夹的责任是XPar的责任，无须调度，所以XDir不从`pending`开始；

在XPar中使用并发方式一次性创建全部子文件夹，如果遇到命名冲突，冲突的文件夹会建立XDir对象，从Conflict状态开始；XDir的状态如下：

1. Working
2. Conflict
3. Finished

XDir的职责很少，对象化（而不是使用函数）的目的是方便销毁。

XPar是递归逻辑的核心，它的起点是目标文件夹已经建立的时刻，即具有dst参数；XPar具有如下状态

1. Reading，读取src，产生任务
2. Working，调度所有子任务，处理错误
3. Finished

XPar的Reading状态可以接受entries参数，该参数可以理解为Filter，即仅操作源文件夹下的这些文件名；

XPar的Working过程是内部执行创建文件夹









1. Pending，等待调度

所以把文件夹的创建设定为父文件夹的责任；父文件夹的工作流程如下：

1. 读取源文件夹的全部内容（对于根文件夹，这一步骤跳过，由客户端提供）
2. Stat所有源文件夹的内容
    + 如果整体失败
3. 创建全部子文件夹
    + 如果整体
    + 对于成功的文件夹，列入队列
    + 对于冲突的文件夹，建立冲突队列
    + 对于失败的文件夹，
4. 依次处理成功队列的子文件夹
5. 依次处理文件





1. 文件夹的创建是父文件夹的责任（处于Parenting状态）
2. 如果文件夹创建成功，则进入Parenting状态
















## 3.6. 静态结构

`xcopy`使用组合状态机实现；

顶层任务容器本身由`copy`, `move`, `import`, `export`四个子类分别实现对应业务，具有共同的基类`base`；

`File`是复制或移动一个文件的基类，具有四个子类`FileCopy`, `FileMove`, `FileImport`和`FileExport`；

`Dir`是复制或移动一个文件夹的基类，具有四个子类`DirCopy`, `DirMove`, `DirImport`和`DirExport`；

`File`和`Dir`均继承自`Node`，是`EventEmitter`，使用**同步**方式emit状态变化；

## 3.7. 行为





### 3.7.1. 状态

File具有`Pending`, `Working`, `Conflict`, `Failed`和`Finished`五个状态；

`Pending`是等待调度的状态，只有调度器可以改变该状态；

`Working`是正在复制或者移动文件的状态；

`Conflict`是冲突状态，用户可以修改；

`Failed`和`Finished`分别是失败和成功状态；

Dir具有`Pending`, `Working`, `Reading`, `Read`, `Failed`和`Finished`五个状态；

`Pending`是等待调度的状态，只有调度器可以改变该状态；

`Working`是正在复制或者移动文件夹的状态；

`Reading`是在创建目标文件夹成功后，读取源文件夹内容的状态；该操作成功后会创建子任务；

`Read`是等待全部子任务完成的状态；

`Failed`和`Finished`分别是失败和成功状态；

### 3.7.2. 生命周期方法

destroy操作设计为析构意义上的对象销毁，而不是对象在destroy之后需要异步迁移到成功或失败的结束状态，所以destroy可以用同步方法实现；这要求每个`Node`对象都实现destroy方法；对于执行操作的状态，应使用状态变量block操作的继续。

### 3.7.3. 事件


### 3.7.4. 组合事件

Dir节点在Read状态下会获得子节点组合事件；



### 3.7.5. 调度


# 4. 测试

## 4.1. 分析

`xcopy`是服务器端有态的状态机，且组合状态空间庞大；测试的关键是把状态机考虑成stepper，如果能在stepper意义上穷举所有的step组合，则可以视为测试覆盖了全部状态。

虽然`xcopy`内部采用了并发实现，但并发是为了效率，从设计上说，应该尽可能让`xcopy`的执行顺序具有确定性，以利于测试。

另外一个问题是考虑通过钩子或参数让状态机可以在某个step之后停下来；在状态机停下来时，测试程序可以修改系统和文件系统的数据，制造错误条件；理想情况下，所有在设计中涵盖的错误都可以用这个办法触发。

最后，`xcopy`测试的主要目的是测试`xcopy`模块自身的逻辑，而不是它依赖的vfs/nfs服务，所以测试的重点是`xcopy`模块的自身状态。

## 4.2. 状态机的状态

状态机有组合特征。在黑盒的角度看，`file`和`dir`模块在内部的一些子状态是不可见的，例如`pending`；一个子任务通过接口能看到的状态只有：

1. 任务尚未开始执行；
2. 任务正在执行；
3. 遇到命名冲突；
4. 遇到错误失败；














